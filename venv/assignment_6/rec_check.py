import recommendations as rec
import recordtype  # mutable namedtuples
import time
#data.tsv: imdb ratings by imdb id, from imdb site
#titles.tsv: contains imdb id and movie name, from imdb site
#imdb_titles.txt contains imdb id and movie title for movies also in movielens data set, generated by this program

ratings_file = open("movielens/u.data", "r")  # user id | item id | rating | timestamp  # 196     242     3       881250949
movies_file = open("movielens/u.item", "r")  # movie id | movie title | release date | video release date | IMDb URL | unknown | Action | Adventure | Animation | etc. |
# 161|Top Gun (1986)|01-Jan-1986||http://us.imdb.com/M/title-exact?Top%20Gun%20(1986)|0|1|0|0|0|0|0|0|0|0|0|0|0|0|1|0|0|0|0
# user | age | gender | occupation | zip code  # 1|24|M|technician|85711

myAge="25"
myGender="M"
myOccupation="student"
prefs = rec.loadMovieLens()
userMatches = []
substitute = "584"

#print people_prefs["Akira (1988)"] #find all reviews by movie title
#print prefs[substitute] # find all reviews by user

with open("movielens/u.user", "r") as userlist: #find matching users
    for line in userlist:
        #print line
        user, age, gender, occupation, zip = line.split("|")
        if (age == myAge) and (gender == myGender) and (occupation == myOccupation):
            userMatches.append(user)
            userMatches=userMatches[-3:] # grab the last 3 user matches made
print "matching users list:", userMatches # part 1

for user in userMatches:
    list = prefs[user]
    topList = sorted(list, key=lambda rating: rating[1])[-3:] #sorts by user rating
    botList = sorted(list, key=lambda rating: rating[1], reverse=True)[-3:] #reversed order

    print "user", user, "------------------"  #part 1 also
    print "most liked movies"
    print topList
    print "least liked movies"
    print botList


correlated_list = []
with open("movielens/u.user", "r") as userlist: #find matching users
    for line in userlist:
        id, age, gender, occupation, zip = line.split("|")
        if id == substitute:
            continue
        current_cor = rec.sim_pearson(prefs, substitute, id)
        correlated_list.append([current_cor, id])

sorted_by_correlation = sorted(correlated_list)#[-5:] # sorted list of users correlated to substitute
least_correlated_users = sorted_by_correlation[::-1][-5:] # top 5 least correlated users: [::-1] reverses the list
most_correlated_users = sorted_by_correlation[-5:] # top 5 most correlated users
print "most correlated users and their correlation value", most_correlated_users # part 2
print "least correlated users and their correlation value", least_correlated_users # part 2

top_matches = []
bot_matches = []
top_matches = rec.topMatches(prefs, substitute, 5)
bot_matches = rec.botMatches(prefs, substitute, 5)
print top_matches
print bot_matches







































'''
incomplete work on extra credit problem 5
movie = recordtype.recordtype("Movie", "id title") # named tuple containing movie id and title
movies = []
ratingList= []
movielens_titlelist = []

with open("movielens/u.item", "r") as movielist:
    for line in movielist:
        id, title, release, release2, imdb_url, unknown, action, adventure, animation, childrens, comedy, crime, documentary, drama, fantasy, film_noir, horror, musical, mystery, romance, sci_fi, thriller, war, western = line.split("|")
        id_int=int(id)
        movies.append(movie(id=id, title=title))


def update_rating():
    ratingList.append(ratingTuple(id=123, title="test movie", rating=3, raters=5))
    for item in ratingList:
        if item.id == 123:
            item.rating = (item.rating * item.raters) + 2
            item.raters +=1
            item.rating = item.rating / float(item.raters)
            print item.title, item.rating

ratingTuple = recordtype.recordtype("rating", "id title rating raters")
movieArchiveTuple = recordtype.recordtype("archive", "id title rating")

def generate_cross_list():
    # generates imdb_title.txt from title.basics.tsv.gz file (renamed to title.tsv) to make a much smaller list of movies in both databases

    #short list
    with open("movielens/u.item", "r") as quick_list:
        for line in quick_list:
            id, title, release, release2, imdb_url, unknown, action, adventure, animation, childrens, comedy, crime, documentary, drama, fantasy, film_noir, horror, musical, mystery, romance, sci_fi, thriller, war, western = line.split(
                "|")
            id_int = int(id)
            title = title[:-7]  # strips year from title
            if title[-5:] == ", The":
                title = "The" + title[:-5]  # adjusts name imdb data set's style
            if title[-3:] == ", A":
                title = "A " + title[:-3]  # adjusts name imdb data set's style
            movielens_titlelist.append(title)

    imdb_quicklist = []
    imdb_cross_title = open("imdb_titles.txt", "w")

    with open("title.tsv", "r") as imdblist:
        for line in imdblist:
            id, type, title, originalTitle, isAdult, startYear, endYear, runtimeMinutes, genres = line.split("	")
            try:
                if type == "movie" and int(startYear) < 2000:
                    for name in movielens_titlelist:
                        if name == title and name not in imdb_quicklist:
                            imdb_quicklist.append(title)
                            imdb_cross_title.write(id+"|"+title+"\n")
                            print title
            except:
                pass

# unfinished and bad
# iterate through each id in quicklist, grab those ratings, write title, ratings, raters to new file to use alongside movielens data
def generate_imdb_ratings_list():
    counter = 0
    total=float(919000)
    imdb_ratings_output = open("imdb_ratings.txt", "w")
    imdb_titles_quicklist = []
    imdb_rating_final_list = []
    with open("imdb_titles.txt", "r") as imdb_titles_file:
        for line in imdb_titles_file:
            id, title = line.split("|")
            imdb_titles_quicklist.append(ratingTuple(id=id, title=title[:-1], rating=0, raters=0))
        with open("data2.tsv") as imbdratings:
            for line in imbdratings:
                counter += 1
                #print counter/total
                #try:
                id, rating, raters = line.split("	")
                #try:
                for each in imdb_titles_quicklist:
                    #print "current id:", id, "checking id", each.id
                    if id==each.id:
                        imdb_rating_final_list.append(ratingTuple(id=each.id, title = each.title, rating=rating, raters = raters ))
                        print "found one"
                #except:
                    #print id
                    #pass
                #except:
                    #print "big error"
                    #pass
    for each in imdb_rating_final_list:
        imdb_ratings_output.write(each.id+"|"+each.title+"|"+each.rating+"|"+each.raters)
'''
